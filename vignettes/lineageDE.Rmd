---
title: "lineageDE workflow"
author: "Matthieu Doutreligne"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{lineage DE workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography : /home/matthieu/Documents/Berkeley/work_Berkeley/paper/library.bib
link-citations: true
---

```{r setup, include = F}
knitr::opts_chunk$set(cache=TRUE, message = F, warning = F, fig.height=4, fig.width=6, fig.align="center")
library(ggplot2)
theme_update(plot.title = element_text(hjust = 0.5))
```

# 1 - Introduction

This vignette will describe the workflow of the R package `lineageDE`, showing two different methods to infer differentially expressed genes from reconstructed cell lineages. After a step of cell ordering reconstruction performed with `Slingshot` (see [@Street2017]) we try to find genes with significantly different behaviours between two cell lineages.

This vignette will use the data from [@Fletcher2017] of Olfactory Epithelium cells from mouses. We restricted the data to only two cell lineages for simplicity purpose.
<!-- ![Cell lineages in the study](images/fig:lignees_study.png) -->

<img src="images/fig:lignees_study.png" alt="alt text" width=100% height=30%>
<center>Cell lineages used in the study</center>

## 1.1 - Preprocessing of the data for our analysis

Before searching for differentially expressed genes between lineages, we have to preprocess the data and run slingshot on it. We use data from [@Fletcher2017], which is already filtered and normalized with [Scone](https://github.com/YosefLab/scone) . Scone tries different normalization techniques, batch or technical effects removal methods and provides tools to rank this different normalizations.

We load this data from the package [lineageDE](https://github.com/strayMat/lineageDE) which contains also the different functions that we use in this study. We also load the package [slingshot](https://github.com/kstreet13/slingshot) [@Street2017] which allows us to perform the lineage inferrence.

```{r}
library(lineageDE)
library(slingshot)
# For nice color
library(RColorBrewer)
#data("OE_counts")
setwd("/home/matthieu/Documents/Berkeley/work_Berkeley/lineageDE")
load("Data/OE_counts.RData")
```

We perform a usual transformation with `log(1+x)` and we run PCA as the dimension reduction technique:
```{r}
pca <- prcomp(t(log1p(counts)))
# nice colors for the clusters
clust_col = brewer.pal(length(unique(clusters)),"Set3")[as.numeric(clusters)] 
plot3d(pca$x[,1:3], col = clust_col)
```

We apply slingshot to infer the lineages curves: 
```{r}
slrun <- slingshot(pca$x[,1:3], clusters, start.clus = '1', end.clus = '4')
plot3d(pca$x[,1:3], col = clust_col)
plot3d.SlingshotDataSet(slrun, type = "curves", add = T)
```

```{r,fig.height=5, fig.width=5, fig.align="center"}
# generate 2D captures of the 3d plots for the rmarkdown
par(cex.main = 1)
plot(pca$x[,1:2], col = clust_col, pch=16, asp = 1)
for(c in curves(slrun)){ 
  lines(c$s[c$tag,c(1,2)], lwd = 1)
}
title("View of the first two Pcs of the data with principal curves")
```

Then, we store the slingshot outputs for our future DE analysis, and create a new data objects with the desired inputs:
```{r}
times <- pseudotime(slrun)
weights <- curveWeights(slrun)
# Normalization of the weights (we want convex weights)
w1 <- weights[,1]/(weights[,1] + weights[,2])
w2 <- weights[,2]/(weights[,1] + weights[,2])
w <- cbind(w1,w2)
df <- new("lineageDEDataSet", counts = counts, t = times, w = w)
```

# 2 - Visualization of the data

We plot the gene expression profile for the first gene of the dataset: CreER
The points are colored by lineage: red is the first lineage (GBC and neuronal cells) and blue is the second lineage (sustentacular cells).
```{r,fig.height=4, fig.width=6, fig.align="center"}
gene <- "CreER"
reg_loess(df, gene, regression = F)
```

We fit a different loess regression for each lineage and one loess regression including both lineages at the same time (the null model). This gives us a representation of the activation pattern for a given gene.
```{r,fig.height=4, fig.width=6, fig.align="center"}
reg_loess(df, gene, legend.show = T)$pl
```

The main goal of the analysis is to find genes which are strongly differrentially expressed between the two reconstructed lineages. In a sense we are searching for branching expression pattern, branching curves uin our visualization.
```{r, fig.show = "hold"}
reg_vgam(df, 'Ncaph2')$pl 
reg_vgam(df, 'Cyp2g1')$pl 
```

On the left, we see an unintersting pattern for us, because both genes are expressed similarly in both lineages.
On the right, we displayed Cyp2g1, a differentially expressed gene similar to the one that we want to detect.

# 3 - Likelihood method

```{r, include = F, echo = F}
# load ranking instead of computing them in order to gain time for knit (from 30 min to 2 min)
load("/home/matthieu/Documents/Berkeley/work_Berkeley/0rmd_lineageDE/rankings/vgam.rank.RDATA")
load("/home/matthieu/Documents/Berkeley/work_Berkeley/0rmd_lineageDE/rankings/loess.rank.RDATA")
load("/home/matthieu/Documents/Berkeley/work_Berkeley/0rmd_lineageDE/rankings/euclidean.ranking.RDATA")
load("/home/matthieu/Documents/Berkeley/work_Berkeley/0rmd_lineageDE/rankings/dtw.rankings.RDATA")
```

The comparision between the alternative model and the null model can be computed via likelihood ratio test or with AIC. The function \code{likelihood_rank} computes these values and returns a ranking. This ranking function takes a few minutes to run.
```{r, include = T, eval = F}
lkl.rank <- likelihood_rank(df, reg = "vgam")
vgam.aic.ranking <- lkl.rank$aic
vgam.pval.ranking <- lkl.rank$pval
```

```{r}
plot_multigenes(df, vgam.aic.ranking, rownames(ranking.df(vgam.aic.ranking))[1:9], grid.size = c(2,4))
plot_multigenes(df, vgam.pval.ranking, rownames(ranking.df(vgam.pval.ranking))[1:9], grid.size = c(2,4))

```

# 4 - DTW method

Another way to infer differentially expressed genes is to consider the gene counts as time series data. Thus, for each gene we compare the difference between each lineages with the Dynamic Time Warping distance which allows local distorsions of the time axis.

```{r, include = T, eval = F}
dtw.ranking <- dtw_rank(df)
```

```{r}
plot_multigenes(df, dtw.ranking, rownames(ranking.df(dtw.ranking))[1:9], grid.size = c(2,4))
```

# 5 - Compare different rankings of genes

## One versus one comparison 
You can compare two rankings with the `compare_rankings` function which wrapps three different comparison:
- A scatter plot of both lineages;
- A comparison of the shared elements in the differents quantiles of the two rankings
- A measure of the [Kendall's tau](https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient) between the two rankings (a measure of the number of concordant and discordant permutations of ranks). 
```{r}
dtw_vgam <- compare_rankings(dtw.ranking, vgam.aic.ranking)
dtw_vgam$pl
dtw_vgam$quantiles.shared
dtw_vgam$kendall.tau
```

## Multiple comparisons

We provided `kendall.heatmap` a quick visualization for multiple rank comparisons:

```{r}
kendall.heatmap(list(vgam.aic.ranking, lo.aic.ranking, dtw.ranking,euclidean.ranking))
```
# Explore one particular ranking

We
```{r}

```

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css
You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))

# References

